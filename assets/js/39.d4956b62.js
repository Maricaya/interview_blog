(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{400:function(e,t,a){"use strict";a.r(t);var v=a(42),s=Object(v.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"新特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#新特性"}},[e._v("#")]),e._v(" 新特性")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://www.bilibili.com/video/av837839066/",target:"_blank",rel:"noopener noreferrer"}},[e._v("【Vue3.0】尤雨溪 - 聊聊 Vue.js 3.0 Beta 官方直播完整版 2020-04-21"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"六大亮点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#六大亮点"}},[e._v("#")]),e._v(" 六大亮点")]),e._v(" "),a("ul",[a("li",[e._v("Proxy：不只是解决了 "),a("code",[e._v("defineProperty")]),e._v(" 的局限性。")]),e._v(" "),a("li",[a("code",[e._v("Performance")]),e._v("：性能更比 Vue 2.0 强。")]),e._v(" "),a("li",[a("code",[e._v("Tree shaking support")]),e._v("：可以将无用模块“剪辑”，仅打包需要的。")]),e._v(" "),a("li",[a("code",[e._v("Composition API")]),e._v("：组合 API。")]),e._v(" "),a("li",[a("code",[e._v("Fragment, Teleport, Suspense")]),e._v("：“碎片”，"),a("code",[e._v("Teleport")]),e._v(" 即 "),a("code",[e._v("Protal")]),e._v(" 传送门，“悬念”。")]),e._v(" "),a("li",[a("code",[e._v("Better TypeScript support")]),e._v("：更优秀的 "),a("code",[e._v("Ts")]),e._v(" 支持。")]),e._v(" "),a("li",[a("code",[e._v("Custom Renderer API")]),e._v("：暴露了自定义渲染 API。")])]),e._v(" "),a("h2",{attrs:{id:"performance"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#performance"}},[e._v("#")]),e._v(" Performance")]),e._v(" "),a("ol",[a("li",[e._v("重写了虚拟Dom的实现（且保证了兼容性，脱离模版的渲染需求旺盛）。")]),e._v(" "),a("li",[e._v("编译模板的优化。")]),e._v(" "),a("li",[e._v("更高效的组件 初始化。")]),e._v(" "),a("li",[e._v("update性能提高1.3~2倍。")]),e._v(" "),a("li",[e._v("SSR速度提高了2~3倍。")])]),e._v(" "),a("h3",{attrs:{id:"要点1-编译模板的优化-不再遍历静态节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#要点1-编译模板的优化-不再遍历静态节点"}},[e._v("#")]),e._v(" 要点1：编译模板的优化：不再遍历静态节点")]),e._v(" "),a("p",[e._v("Vue 在运行时会生成 "),a("code",[e._v("number")]),e._v("（大于0）值的 "),a("code",[e._v("PatchFlag")]),e._v("，用作标记动态节点。")]),e._v(" "),a("p",[e._v("仅带有 "),a("code",[e._v("PatchFlag")]),e._v(" 标记的节点会被真正追踪，且无论层级嵌套多深，")]),e._v(" "),a("p",[e._v("它的动态节点都直接与 "),a("code",[e._v("Block")]),e._v(" 根节点绑定，无需再去遍历静态节点")]),e._v(" "),a("p",[e._v("？\n这样既跳出了 "),a("code",[e._v("virtual dom")]),e._v(" 性能的瓶颈，又保留了可以手写 "),a("code",[e._v("render")]),e._v(" 的灵活性。\n等于是：既有 "),a("code",[e._v("react")]),e._v(" 的灵活性，又有基于模板的性能保证。")]),e._v(" "),a("h3",{attrs:{id:"要点2-事件监听缓存-cachehandlers"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#要点2-事件监听缓存-cachehandlers"}},[e._v("#")]),e._v(" 要点2: 事件监听缓存："),a("code",[e._v("cacheHandlers")])]),e._v(" "),a("p",[e._v("假设我们要绑定一个事件：")]),e._v(" "),a("div",{staticClass:"language-html line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-html"}},[a("code",[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),e._v("div")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),e._v("span")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("@click")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[e._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v('"')]),e._v("onClick"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v('"')])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v("\n    {{msg}}\n  "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("</")]),e._v("span")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("</")]),e._v("div")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br")])]),a("ul",[a("li",[a("p",[e._v("关闭 "),a("code",[e._v("CacheHandlers")]),e._v("：")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("onClick")]),e._v(" 会被视为 "),a("code",[e._v("PROPS")]),e._v(" 动态绑定，后续替换点击事件时需要进行更新。")])])]),e._v(" "),a("li",[a("p",[e._v("开启 cacheHandlers 后：")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("cache[1]")]),e._v("，会自动生成并缓存一个内联函数，节点 "),a("code",[e._v("PatchFlags")]),e._v(" 变成 1 （具有动态 "),a("code",[e._v("textContent")]),e._v(" 的元素）。 Ps：相当于 "),a("code",[e._v("React中useCallback")]),e._v(" 自动化。")])])])]),e._v(" "),a("h2",{attrs:{id:"tree-shaking-support"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tree-shaking-support"}},[e._v("#")]),e._v(" Tree shaking support")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("可以将无用模块“剪辑”，仅打包需要的（比如 "),a("code",[e._v("v-model")]),e._v(","),a("code",[e._v("<transition>")]),e._v("，用不到就不会打包）。")])]),e._v(" "),a("li",[a("p",[e._v("一个简单 "),a("code",[e._v("“HelloWorld”")]),e._v(" 大小仅为：13.5kb")]),e._v(" "),a("ul",[a("li",[e._v("11.75kb，仅 "),a("code",[e._v("Composition API")]),e._v("。")])])]),e._v(" "),a("li",[a("p",[e._v("包含运行时完整功能：22.5kb")]),e._v(" "),a("ul",[a("li",[e._v("拥有更多的功能，却比Vue 2更迷你。")])])])]),e._v(" "),a("p",[e._v("很多时候，我们并不需要 vue提供的所有功能，在 vue 2 并没有方式排除掉，但是 3.0 都可能做成了按需引入。")]),e._v(" "),a("h2",{attrs:{id:"composition-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#composition-api"}},[e._v("#")]),e._v(" Composition API")]),e._v(" "),a("p",[e._v("与React Hooks 类似的东西，实现方式不同。")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("可与现有的 Options API一起使用")])]),e._v(" "),a("li",[a("p",[e._v("灵活的逻辑组合与复用")])]),e._v(" "),a("li",[a("p",[e._v("vue 3的响应式模块可以和其他框架搭配使用")])])]),e._v(" "),a("p",[e._v("混入("),a("code",[e._v("mixin")]),e._v(") 将不再作为推荐使用， "),a("code",[e._v("Composition API")]),e._v(" 可以实现更灵活且无副作用的复用代码。")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://composition-api.vuejs.org/zh/api.html#readonly",target:"_blank",rel:"noopener noreferrer"}},[e._v("响应式系统 API"),a("OutboundLink")],1)]),e._v(" "),a("h3",{attrs:{id:"reactive"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reactive"}},[e._v("#")]),e._v(" "),a("code",[e._v("reactive")])]),e._v(" "),a("h3",{attrs:{id:"ref"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ref"}},[e._v("#")]),e._v(" "),a("code",[e._v("ref")])]),e._v(" "),a("h3",{attrs:{id:"watcheffect-监听副作用-vs-watch-监听"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#watcheffect-监听副作用-vs-watch-监听"}},[e._v("#")]),e._v(" "),a("code",[e._v("watchEffect")]),e._v(" 监听副作用 vs "),a("code",[e._v("watch")]),e._v(" 监听")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("第一点我们可以从示例代码中看到 watchEffect 不需要指定监听的属性，他会自动的收集依赖， 只要我们回调中引用到了 响应式的属性， 那么当这些属性变更的时候，这个回调都会执行，而 watch 只能监听指定的属性而做出变更(v3开始可以同时指定多个)。")])]),e._v(" "),a("li",[a("p",[e._v("第二点就是 watch 可以获取到新值与旧值（更新前的值），而 watchEffect 是拿不到的。")])]),e._v(" "),a("li",[a("p",[e._v("第三点是 watchEffect 如果存在的话，在组件初始化的时候就会执行一次用以收集依赖（与computed同理），而后收集到的依赖发生变化，这个回调才会再次执行，而 watch 不需要，因为他一开始就指定了依赖。")])])]),e._v(" "),a("h3",{attrs:{id:"与-react-hooks-相比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#与-react-hooks-相比"}},[e._v("#")]),e._v(" 与 React Hooks 相比")]),e._v(" "),a("p",[e._v("基于函数的组合式 API 提供了与 React Hooks 同等级别的逻辑组合能力，但是与它还是有很大不同：组合式 API 的 "),a("code",[e._v("setup()")]),e._v(" 函数只会被调用一次，这意味着使用 Vue 组合式 API 的代码会是：")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("一般来说更符合惯用的 JavaScript 代码的直觉；")])]),e._v(" "),a("li",[a("p",[e._v("不需要顾虑调用顺序，也可以用在条件语句中；")])]),e._v(" "),a("li",[a("p",[e._v("不会在每次渲染时重复执行，以降低垃圾回收的压力；")])]),e._v(" "),a("li",[a("p",[e._v("不存在内联处理函数导致子组件永远更新的问题，也不需要 "),a("code",[e._v("useCallback")]),e._v("；")])]),e._v(" "),a("li",[a("p",[e._v("不存在忘记记录依赖的问题，也不需要“"),a("code",[e._v("useEffect")]),e._v("”和“"),a("code",[e._v("useMemo")]),e._v("”并传入依赖数组以捕获过时的变量。\nVue 的自动依赖跟踪可以确保侦听器和计算值总是准确无误。")])])]),e._v(" "),a("p",[e._v("我们感谢 React Hooks 的创造性，它也是本提案的主要灵感来源，然而上面提到的一些问题存在于其设计之中，且我们发现 Vue 的响应式模型恰好为解决这些问题提供了一种思路。")]),e._v(" "),a("h2",{attrs:{id:"fragment"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fragment"}},[e._v("#")]),e._v(" Fragment")]),e._v(" "),a("p",[e._v("Fragment 翻译为：“碎片”")]),e._v(" "),a("ul",[a("li",[e._v("不再限于模板中的单个根节点")]),e._v(" "),a("li",[e._v("render 函数也可以返回数组了，类似实现了 React.Fragments 的功能 。")]),e._v(" "),a("li",[e._v("'Just works'")])]),e._v(" "),a("h3",{attrs:{id:"teleport"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#teleport"}},[e._v("#")]),e._v(" "),a("code",[e._v("<Teleport>")])]),e._v(" "),a("ul",[a("li",[e._v("以前称为 "),a("code",[e._v("<Portal>")]),e._v("，译作传送门。")]),e._v(" "),a("li",[e._v("更多细节将由@Linusborg 分享")])]),e._v(" "),a("p",[a("code",[e._v("<Teleport>")]),e._v(" 原先是对标 "),a("code",[e._v("React Portal")]),e._v("（增加多个新功能，更强）\n但因为 Chrome 有个提案，会增加一个名为Portal的原生element，为避免命名冲突，改为 "),a("code",[e._v("Teleport")])]),e._v(" "),a("h3",{attrs:{id:"suspense"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#suspense"}},[e._v("#")]),e._v(" "),a("code",[e._v("<Suspense>")])]),e._v(" "),a("p",[a("code",[e._v("Suspense")]),e._v(" 翻译为：“悬念”")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("可在嵌套层级中等待嵌套的异步依赖项")])]),e._v(" "),a("li",[a("p",[e._v("支持 "),a("code",[e._v("async setup()")])])]),e._v(" "),a("li",[a("p",[e._v("支持异步组件")])])]),e._v(" "),a("p",[e._v("虽然 React 16 引入了 "),a("code",[e._v("Suspense")]),e._v("，但直至现在都不太能用。如何将其与异步数据结合，还没完整设计出来。")]),e._v(" "),a("p",[e._v("Vue 3 的 "),a("code",[e._v("<Suspense>")]),e._v(" 更加轻量：")]),e._v(" "),a("p",[e._v("仅5%应用能感知运行时的调度差异，综合考虑下，Vue3 的 "),a("code",[e._v("<Suspense>")]),e._v(" 没和React一样做运行调度处理")])])}),[],!1,null,null,null);t.default=s.exports}}]);