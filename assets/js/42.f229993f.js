(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{401:function(t,a,h){"use strict";h.r(a);var s=h(42),v=Object(s.a)({},(function(){var t=this,a=t.$createElement,h=t._self._c||a;return h("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[h("h1",{attrs:{id:"前端路由"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#前端路由"}},[t._v("#")]),t._v(" 前端路由")]),t._v(" "),h("p",[t._v("https://juejin.im/post/6844903589123457031#heading-6\nhttps://juejin.im/post/6854573222231605256#heading-9")]),t._v(" "),h("h2",{attrs:{id:"为什么有-hash-和-history"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#为什么有-hash-和-history"}},[t._v("#")]),t._v(" 为什么有 hash 和 history")]),t._v(" "),h("p",[t._v("前端路由的核心，就在于 —— "),h("strong",[t._v("改变视图的同时不会向后端发出请求")]),t._v("。")]),t._v(" "),h("h2",{attrs:{id:"hash-vs-history"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#hash-vs-history"}},[t._v("#")]),t._v(" hash vs history")]),t._v(" "),h("p",[t._v("https://juejin.im/post/6844903552519766029")]),t._v(" "),h("ol",[h("li",[h("p",[t._v("hash")]),t._v(" "),h("ul",[h("li",[h("p",[t._v("它的特点在于：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。")])]),t._v(" "),h("li",[h("p",[t._v("hash的优势就是兼容性更好,在老版IE中都可以运行。")])]),t._v(" "),h("li",[h("p",[t._v("问题在于url中一直存在 "),h("code",[t._v("#")]),t._v(" 不够美观,而且hash路由更像是Hack而非标准,\n相信随着发展更加标准化的History API会逐步蚕食掉hash路由的市场。")])])])]),t._v(" "),h("li",[h("p",[t._v("history")]),t._v(" "),h("ul",[h("li",[h("p",[t._v("利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。（需要特定浏览器支持）")])]),t._v(" "),h("li",[h("p",[t._v("这两个方法应用于浏览器的历史记录栈，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。")])]),t._v(" "),h("li",[h("p",[t._v("只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求。")])])])])]),t._v(" "),h("h2",{attrs:{id:"原理"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[t._v("#")]),t._v(" 原理")]),t._v(" "),h("h3",{attrs:{id:"hash-实现"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#hash-实现"}},[t._v("#")]),t._v(" hash 实现")]),t._v(" "),h("p",[t._v("hash 是 URL 中 hash (#) 及后面的那部分，常用作锚点在页面内进行导航，"),h("strong",[t._v("改变 URL 中的 hash 部分不会引起页面刷新")])]),t._v(" "),h("p",[t._v("通过 "),h("code",[t._v("hashchange")]),t._v(" 事件监听 URL 的变化，改变 URL 的方式只有这几种：")]),t._v(" "),h("ul",[h("li",[h("p",[t._v("通过浏览器前进后退改变 URL")])]),t._v(" "),h("li",[h("p",[t._v("通过 "),h("code",[t._v("<a>")]),t._v(" 标签改变 URL")])]),t._v(" "),h("li",[h("p",[t._v("通过 window.location 改变URL")])])]),t._v(" "),h("h3",{attrs:{id:"history-实现"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#history-实现"}},[t._v("#")]),t._v(" history 实现")]),t._v(" "),h("p",[t._v("history 提供了 pushState 和 replaceState 两个方法，"),h("strong",[t._v("这两个方法改变 URL 的 path 部分不会引起页面刷新")])]),t._v(" "),h("p",[t._v("history 提供类似 hashchange 事件的 "),h("code",[t._v("popstate")]),t._v(" 事件可供监听，但 popstate 事件有些不同：")]),t._v(" "),h("ul",[h("li",[h("p",[t._v("通过浏览器前进后退改变 URL 时会触发 "),h("code",[t._v("popstate")]),t._v(" 事件")])]),t._v(" "),h("li",[h("p",[t._v("但是，"),h("strong",[t._v("通过 "),h("code",[t._v("pushState")]),t._v("/"),h("code",[t._v("replaceState")]),t._v("或 "),h("code",[t._v("<a>")]),t._v(" 标签改变 URL 不会触发 "),h("code",[t._v("popstate")]),t._v(" 事件。")])])]),t._v(" "),h("li",[h("p",[h("strong",[t._v("好在我们可以拦截 "),h("code",[t._v("pushState/replaceState")]),t._v(" 的调用和 "),h("code",[t._v("<a>")]),t._v(" 标签的点击事件来检测 URL 变化")])])]),t._v(" "),h("li",[h("p",[t._v("通过 "),h("code",[t._v("js")]),t._v(" 调用 "),h("code",[t._v("history")]),t._v(" 的 "),h("code",[t._v("back，go，forward")]),t._v(" 方法课触发该事件")])])]),t._v(" "),h("p",[t._v("所以监听 URL 变化可以实现，只是没有 hashchange 那么方便。")]),t._v(" "),h("h2",{attrs:{id:"router-方法"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#router-方法"}},[t._v("#")]),t._v(" router 方法")]),t._v(" "),h("p",[t._v("VueRouter 类中的 onReady(), push() 等方法只是一个代理，\n实际是调用的具体 history 对象的对应方法，在 init() 方法中初始化时，也是根据 history 对象具体的类别执行不同操作")]),t._v(" "),h("h2",{attrs:{id:"q-a"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#q-a"}},[t._v("#")]),t._v(" Q & A")]),t._v(" "),h("h3",{attrs:{id:"有个问题-hash模式-也可以用history-go-back-forward来触发hashchange事件吗"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#有个问题-hash模式-也可以用history-go-back-forward来触发hashchange事件吗"}},[t._v("#")]),t._v(" 有个问题：hash模式，也可以用history.go,back,forward来触发hashchange事件吗？")]),t._v(" "),h("p",[t._v("A：也是可以的。因为不管什么模式，浏览器为保存记录都会有一个栈。")]),t._v(" "),h("h3",{attrs:{id:"为什么-history-需要后端配置-nginx"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#为什么-history-需要后端配置-nginx"}},[t._v("#")]),t._v(" 为什么 history 需要后端配置 nginx？")]),t._v(" "),h("p",[t._v("当然啦，history 也不是样样都好。SPA 虽然在浏览器里游刃有余，但真要通过 URL 向后端发起 HTTP 请求时，两者的差异就来了。")]),t._v(" "),h("p",[t._v("尤其在用户手动输入 URL 后回车，或者刷新（重启）浏览器的时候。")]),t._v(" "),h("ol",[h("li",[h("p",[h("code",[t._v("hash")]),t._v(" 模式下，仅 hash 符号之前的内容会被包含在请求中，如 http://www.abc.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。")])]),t._v(" "),h("li",[h("p",[h("code",[t._v("history")]),t._v(" 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 http://www.abc.com/book/id。如果后端缺少对 /book/id 的路由处理，将返回 404 错误。")])])]),t._v(" "),h("p",[h("strong",[t._v("Vue-Router 官网里如此描述：“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。”")])])])}),[],!1,null,null,null);a.default=v.exports}}]);