(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{368:function(l,v,_){"use strict";_.r(v);var i=_(42),t=Object(i.a)({},(function(){var l=this,v=l.$createElement,_=l._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":l.$parent.slotKey}},[_("h1",{attrs:{id:"垃圾回收"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[l._v("#")]),l._v(" 垃圾回收")]),l._v(" "),_("p",[l._v("从三个点来回答什么是垃圾、如何捡垃圾、什么时候捡垃圾。")]),l._v(" "),_("ol",[_("li",[_("p",[l._v("什么是垃圾")]),l._v(" "),_("ul",[_("li",[_("p",[l._v("不再需要，即为垃圾")])]),l._v(" "),_("li",[_("p",[l._v("全局变量随时可能用到，所以一定不是垃圾")])])])]),l._v(" "),_("li",[_("p",[l._v("如何捡垃圾（遍历算法）")]),l._v(" "),_("ul",[_("li",[l._v("标记空间中「可达」值。\n"),_("ul",[_("li",[l._v("从根节点（Root）出发，遍历所有的对象。")]),l._v(" "),_("li",[l._v("可以遍历到的对象，是可达的（reachable）。")]),l._v(" "),_("li",[l._v("没有被遍历到的对象，不可达的（unreachable）")])])]),l._v(" "),_("li",[l._v("回收「不可达」的值所占据的内存。做内存整理。")])])]),l._v(" "),_("li",[_("p",[l._v("什么时候捡垃圾")]),l._v(" "),_("ul",[_("li",[l._v("前端有其特殊性，垃圾回收的时候会造成页面卡顿。")]),l._v(" "),_("li",[l._v("分代收集\n"),_("ul",[_("li",[l._v("把数据分为新生代、老生代")]),l._v(" "),_("li",[l._v("老生代：标记-清除-整理 执行垃圾回收。\n"),_("ul",[_("li",[l._v("优点的是无需移动对象，缺点是产生内存碎片，需要清除内存碎片，速度较慢。")])])]),l._v(" "),_("li",[l._v("新生代："),_("code",[l._v("Scavenge")]),l._v(" 算法。\n"),_("ul",[_("li",[l._v("将内存一分为二，对象区、空间区。\n"),_("ul",[_("li",[l._v("标记对象区，将存活对象有序地复制到空闲区，然后对调两个区数据")])])]),l._v(" "),_("li",[l._v("优点是速度快无内存碎片，缺点是占用双倍内存空间。")])])]),l._v(" "),_("li",[l._v("一句话总结分代回收就是：将堆分为新生代与老生代，多回收新生代，少回收老生代。")])])]),l._v(" "),_("li",[l._v("增量收集\n"),_("ul",[_("li",[l._v("引擎将垃圾收集工作分成更小的块，每次处理一部分，多次处理。\n这样就解决了长时间停顿的问题。")])])]),l._v(" "),_("li",[l._v("闲时收集\n"),_("ul",[_("li",[l._v("垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。")])])])])])])])}),[],!1,null,null,null);v.default=t.exports}}]);